{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Lab work 2020-02-20"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "[Best up-to-date python tutorial](https://docs.python.org/3.7/tutorial/index.html)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Packages\n",
    "\n",
    "When starting python document importing of packages usually go first. These packages extend programs with previous work done by us or somebody else."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "For example here we import math package. It has a lot of functions helping with variuos math problems. For example the definition of pi can be accessed by executing `math.pi`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import math"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Calculator\n",
    "Lets use python as a calculator and do some basic math:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "2+2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "math.sqrt(4)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "3**2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "6/2"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "lines_to_next_cell": 2
   },
   "source": [
    "---\n",
    ">> **TASK**\n",
    ">>\n",
    ">> In python REPL (REPL is the language shell, the Python Interactive Shell. The REPL acronym is short for Read, Eval, Print and Loop) write `math.` and then press `TAB`. Pressing tab in ipython will reveal implemented functions in math package. Explore them, try to implement basic math operators (Find sin, cos, log, exponentof number 42).\n",
    ">>\n",
    "---"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## IPython"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "IPython gives many useful functions to basic python REPL.\n",
    "Very important addition is easy access of functions documentation with `?`. Try to access documentation of basic math functions."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "math.sin?"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " Full documentation can be accessed with help"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "help(math)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Ability to run bash commands and quickly explore the contents of the current directory is very handy during data analysis\n",
    "Just like in bash we can get current directory with:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "pwd"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The contents of current directory with:"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "ls -a"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "and so on..."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Other useful addition is workspace control. We always can get the previous outputs and inputs by their name."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "In[-9]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "As you can see to get the output of the output or input number X one could write In[X] or Out[X]. But it is possible to go from the last elements and reverse the numbering --- last element is Out[-1] second before last Out[-2] and so on"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " If one would like to get first three Inputs:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "In[1:5]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The colon operator slices from number x to y in this case from 1 to 5.\n",
    " \n",
    "Remember that python counts from 0 so the first element is at 0"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " These shortcuts can lead to faster and smoother data exploration"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "---\n",
    ">> **Task**\n",
    ">>\n",
    ">> - Test IPython magical functions. `%lsmagic`, `%magic` and `alias`\n",
    ">>    - Find out the directory you are in.\n",
    ">>    - Navigate to ~/Documents/bioa/ directory.\n",
    ">>\n",
    ">>\n",
    "---"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " When writing code it is important to write comments to make it easier for you (in a week) or other persons to read and understand it. Comments  in python are written after a hash tag # and they are ignored by python interpreter. When writing in JupyterLab notebook it is better to make comments in markdown cells."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# python will ignore this\n",
    "# pwd"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Data types"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Lets make a Celsius to Fahrenheit converter. The basic formula for conversion is y = (x Ã— 9/5) + 32\n",
    "\n",
    "where y is temperature in Fahrenheit and x temperature in Celsius.\n",
    "\n",
    "Lets find out what is in the temperature in Fahrenheit when temperature in Celsius is 100C.\n",
    "\n",
    "First we could simply write out the formula like that:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "lines_to_next_cell": 2
   },
   "outputs": [],
   "source": [
    "(100 * 9/5) + 32"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "For later use we could create a variable in memory that would store the result:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "Fahrenheit = (100 * 9/5) + 32\n",
    "Fahrenheit"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now variable Fahrenheit stores the results of that operation.\n",
    "\n",
    "There are a couple variable types in python for number storage. The simplest `int` (Integer) represents real integer numbers.\n",
    "\n",
    "Our created variable Fahrenheit is a `float` -- it has higher precision then `int` but for that it occupies more space in memory. We can find out the type of the variable by writing"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "type(Fahrenheit)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can also change the type by casting it to other type"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "int(Fahrenheit)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "lines_to_next_cell": 2
   },
   "source": [
    "Take note that Fahrenheit  variable was not changed you have to assign the output of the operation to change it"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "Fahrenheit = int(Fahrenheit)\n",
    "Fahrenheit"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "There are 5 core variable types"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Integer"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "10"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " Float"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "3.14"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "it is possible to use scientific notation with floats"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "4e2"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Boolean - True and False or 1 and 0"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "jupyter": {
     "source_hidden": true
    }
   },
   "outputs": [],
   "source": [
    "type(True)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Complex"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "type(3 + 4j)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "String"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "message = 'Hello world'\n",
    "message"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " And 4 compound types for multiple variable storage"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "List"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "[1,2,3]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Tuple"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "(1,2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Set"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "{1,2}"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Dictionary"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "{'key':'value'}"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " We will explore them in more detail later"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "In IPython we can get all objects in current workspace by typing:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "who"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can clear all variables in workspace with `reset`"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "---\n",
    ">> **TASK**\n",
    ">>\n",
    ">> - Explore the documentation of reset and find a way to clear only one variable. Clear Fahrenheit but keep the rest.\n",
    ">>\n",
    "---"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Functions"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "lines_to_next_cell": 2
   },
   "source": [
    "If we want to use the same formula more then once it is wise to create a shortcut. It can be done by creating functions."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "lines_to_next_cell": 2
   },
   "outputs": [],
   "source": [
    "def celsius_to_farenheit(celsius):\n",
    "    fahrenheit = (celsius * 9/5) + 32\n",
    "    return round(fahrenheit)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "lines_to_next_cell": 2
   },
   "source": [
    "Here we created a function that will convert temperature given in Celsius to Fahrenheit. In addition it will round the value with the built-in python method `round`.\n",
    "\n",
    "Functions are defined with keyword `def` and have a basic form:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def functionName(inputVariable):\n",
    "    #  somethingis done here\n",
    "    return something"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Remember python is sensitive to indentation!"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "lines_to_next_cell": 2
   },
   "source": [
    "Now if we want to get the temperature in Fahrenheit of 100 Celsius we simply write"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "celsius_to_farenheit(100)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Lets say we want to calculate temperature for 100 110 and 200 Celsius and store it in one variable. For this task we have lists. Lists are created with square brackets [] and can have mixed type inputs inside. Lists are mutable (it is possible to change them) and ordered (the order items are added is important)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "ListA = [celsius_to_farenheit(100), celsius_to_farenheit(110), celsius_to_farenheit(200)]\n",
    "ListA"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "To get the size of the list:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "lines_to_next_cell": 2
   },
   "outputs": [],
   "source": [
    "len(ListA)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " Lists are one of the most useful storages in python. They have many methods to work with. You can get all methods by pressing TAB in ipython after writing variable name and a dot ."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "ListA."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### The methods:"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Append - adds element to list"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "ListA.append(2)\n",
    "ListA"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "To sort elements in the list"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "ListA.sort()\n",
    "ListA"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Extend -- appends iterable elements (for now think of them as lists and specific iterable functions)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "ListA.extend([1, 2, 3])\n",
    "ListA"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " If we append the list [10,11,12], the whole list is added to the end while with extend we iterate over the list and add elements by one"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "lines_to_next_cell": 2
   },
   "outputs": [],
   "source": [
    "ListA.append([10, 11, 12])\n",
    "ListA"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "count returns number of occurrences of given value in the list"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "ListA.count(2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "To insert object (number 2) before index 1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "ListA.insert(1, 2)\n",
    "ListA"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "to reverse value order in the list"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "ListA.reverse()\n",
    "ListA"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Pop removes and returns an item from the list at given index (default = last)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "ListA.pop(2)\n",
    "ListA"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "After pop displays/returns the number it is removed from the list"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Copy - returns a shallow copy of the list."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "ListB = ListA.copy()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "ListA.append(2)\n",
    "ListA"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "ListB"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " If we simply create copy by assignment"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "ListC = ListA\n",
    "ListC"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "ListA.append(88)\n",
    "ListA"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "ListC"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " we observe that both ListA and ListC changes as ListC is not a separate copy but just a pointer"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Index -- returns first index of the given value"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "ListA.index(3)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Remove -- removes first occurrence of the value"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "ListA.remove(88)\n",
    "ListA"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "clear - clears all items from list"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "lines_to_next_cell": 2
   },
   "outputs": [],
   "source": [
    "ListA.clear()\n",
    "ListA"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " You can get elements in the list by their index"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "ListB[0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "ListB[3]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "ListB[-1]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " Or by slicing the indexes"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "ListB[0:2]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " Lists implement some math operators like:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "ListB * 2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "ListB + ListB"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " Lists can have lists inside lists (nested lists)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "ListC = [ListB, ListB]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "To access first list in ListB:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "ListC[0]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "To access second item in first list in ListB:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "lines_to_next_cell": 2
   },
   "outputs": [],
   "source": [
    "ListC[0][1]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "---\n",
    ">> **TASK**\n",
    ">>\n",
    ">> - Get numbers 78, 55, 0, 45 from the list `TestList`\n",
    ">>\n",
    "---"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "TestList = [1, [79, 77, 78], 0, [2, [45, 65], 55], 4]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "lines_to_next_cell": 2
   },
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "lines_to_next_cell": 2
   },
   "source": [
    "Now lets change our function so it would return back Fahrenheit and Kelvin values"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def celsius_to_farenheit(celsius):\n",
    "    fahrenheit = (celsius * 9/5) + 32\n",
    "    kelvin = celsius - 273.15\n",
    "    return round(fahrenheit), round(kelvin)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "output = celsius_to_farenheit(42)\n",
    "output"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " Variable `output` is called tuple. It is immutable"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "output[1] = 3"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The most useful tuple property for us right now will be unpacking"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "fah, kel = output\n",
    "kel"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "lines_to_next_cell": 2
   },
   "outputs": [],
   "source": [
    "fah"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " we could do the unpacking at the moment of function execution"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "lines_to_next_cell": 2
   },
   "outputs": [],
   "source": [
    "fah, kel = celsius_to_farenheit(42)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " Tuples work faster then lists, are immutable (you can not accidentally change the value) and are often used to form dictionaries"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "To store all the information in a more organized way we can use a dictionary"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " Dictionary is defined by key and value pair `{key: value}`. Keys must be unique and immutable (tuple, integer, string float, boolean). Values in the dictionary are accessed by the unique key. Values are not restricted."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "temperature = {}\n",
    "cel = 34\n",
    "fah, kel = celsius_to_farenheit(cel)\n",
    "temperature[cel] = fah, kel"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "cel = 4\n",
    "fah, kel = celsius_to_farenheit(cel)\n",
    "temperature[cel] = fah, kel"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "cel = -9\n",
    "fah, kel = celsius_to_farenheit(cel)\n",
    "temperature[cel] = fah, kel"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "temperature"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "temperature[4]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " To get all the items in the dictionary use items method"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "temperature.items()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "To get the keys"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "temperature.keys()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " Values given the key can be accessed with get method"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "temperature.get(4)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " There are many ways to create dictionaries:"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "using curly brackets"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "dictA = {'key1':'value1','key2':'value2'}\n",
    "dictA.keys()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "dictA['key1']"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "using dict keyward"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "dictA = dict(key1 = 'value1', key2='value2')\n",
    "dictA"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "using lists of tuples"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "lines_to_next_cell": 2
   },
   "outputs": [],
   "source": [
    "dictA = dict([('key1','value1'),('key2','value2')])\n",
    "dictA"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " The last type is SET. It is a mutable collection of unique unordered values.\n",
    " \n",
    "Using sets we can perform variuos logical operations. For example if we have a list of numbers"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "s = [1,1,1,2,3,5,5]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "converting it to set will leave only unique values"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "lines_to_next_cell": 2
   },
   "outputs": [],
   "source": [
    "ss = set(s)\n",
    "ss"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The methods of sets:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "rr = set([2,4,6,5])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "rr.difference(ss)  # difference between sets"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "rr.intersection(ss)  # returns common elements"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "rr.issubset(ss)  # checks if one set is a subset of other"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "rr.union(ss)  # unites both sets"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "rr.add('k')  # adds elements\n",
    "rr"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "rr.clear()  # removes all elements\n",
    "rr"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "check set help for more methods"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "lines_to_next_cell": 2
   },
   "outputs": [],
   "source": [
    "help(set)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "lines_to_next_cell": 2
   },
   "source": [
    "---\n",
    ">> **TASK**\n",
    ">>\n",
    ">> - Explore dictionary, set and tuple methods\n",
    ">>\n",
    "---"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Printing"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " Finally we want to display the temperature values with some text explaining them. Variable storing text in python is called a string. Strings are defined inside quotation marks."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "stringA = \"This is string A\"\n",
    "stringA"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "stringB = 'This is string B'\n",
    "stringB"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Like lists strings have methods and operations. But stings are immutable and every time we do something with them new objects are created in memory."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "To change all letters to lower case use:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "stringA.lower()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "to change all letters to uppercase"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "stringA.upper()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "+ and * combines strings"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "stringA + stringB"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "stringA * 2"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "But it is better to use join method. It accepts a list of strings and joins them with a separator. In this case we give empty space as a separator ' '."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "' '.join([stringA, stringB])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Split strings into parts with split method"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "stringA.split()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "---\n",
    ">> **TASK**\n",
    ">>\n",
    ">> - Explore string methods\n",
    ">> [full list of methods](https://docs.python.org/3.7/library/stdtypes.html#string-methods)\n",
    ">>\n",
    "---"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Printing"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Built in function `print` formats strings and other variables into text and displays it"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print(stringA)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print(stringA, stringB)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Old way to perform string formatting:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "\"Celsius, %s. Fahrenheit %s.\" % (cel, fah)  # % operator"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "\"Celsius, {0}. Fahrenheit{1}.\".format(cel, fah)  # str.format method"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "It is possible to combine everything with print"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print('Temperature in Celsius', cel, 'Fahrenheit ', fah, sep=' ', end='\\n', flush=False)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "From version 3.6  python supports the fString and rString strings which are easiest to use."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " fStrings replaces curly brackets into variable values:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "f'Temperature in Celsius {cel}'"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "rString prints everything ignoring the special characters"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "r'Temperature in Celsius {cel}'"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " For all types of formating these special characters can help to present text:\n",
    "\n",
    "|special char|displayed|\n",
    "|-----------|----------|\n",
    "|\\t|tab|\n",
    "|\\n|new line|\n",
    "|\\r|Enter, return|\n",
    "|\\b|back|\n",
    "|\\\\|backslash \\|\n",
    "|\\'|quotation mark|\n",
    "|\\\"|double quotation mark|"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print(f'Temperature\\nCelsius {cel}\\t Fahrenheit {fah}')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "lines_to_next_cell": 2
   },
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from time import sleep\n",
    "def progress(percent=0, width=30):\n",
    "    left = width * percent // 100\n",
    "    right = width - left\n",
    "    print('\\r[', '#' * left, ' ' * right, ']',\n",
    "          f' {percent:.0f}%',\n",
    "          sep='', end='', flush=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# we will learn flow control next time\n",
    "for i in range(101):\n",
    "    progress(i)\n",
    "    sleep(0.1)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "lines_to_next_cell": 2
   },
   "source": [
    "---\n",
    ">> **TASK**\n",
    ">>\n",
    ">> - Change progress function to get the display shown below\n",
    ">>\n",
    "---"
   ]
  },
  {
   "cell_type": "raw",
   "metadata": {
    "lines_to_next_cell": 0
   },
   "source": [
    "[  # ] 5%\n",
    "[  # ] 6%\n",
    "[  # ] 7%\n",
    "[  # ] 8%\n",
    "[  # ] 9%\n",
    "[  # ] 10%\n",
    "[  # ] 11%\n",
    "[  # ] 12%"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "lines_to_next_cell": 2
   },
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Plotting"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Finally we need some basic plotting to plot the values we will get. Python has a lot of libraries for this purpose and we will learn the most important ones step by step.\n",
    "For now we will use the core library matplotlib"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " First we have to import it"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Then we create a figure <plt.figure>,\n",
    "add plots <plot(x,y)>,\n",
    "and labels"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "plt.figure(figsize=(20,3)) # creates figure of preferred size\n",
    "plt.plot(list(temperature.keys()),'r+') # convert keys to list and plot in red color as + signs\n",
    "plt.plot(list(temperature.values()),'o') # convert values to list and plot as o signs\n",
    "plt.legend(['Celsius','Fahrenheit','kelvin']) # add legend with values\n",
    "plt.title(\"Temperatures\") # Add title\n",
    "plt.ylabel(\"Degrees\") # Add y label\n",
    "plt.xlabel(\"Measurements\") # Add x label"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "---\n",
    ">> **TASK**\n",
    ">>\n",
    ">> - Make a plot of a list [1,2,3,4]\n",
    ">>\n",
    "---"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "jupytext": {
   "cell_markers": "{{{,}}}",
   "cell_metadata_filter": "-all",
   "encoding": "# -*- coding: utf-8 -*-",
   "formats": "ipynb,py"
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
